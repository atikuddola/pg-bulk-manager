\n\n===== FILE: ./core/workers/backup_worker.py =====\n\n
from PySide6.QtCore import QObject, Signal, QRunnable
from PySide6.QtCore import QProcess
import os


class BackupSignals(QObject):
    progress = Signal(str, int)
    finished = Signal(str)
    error = Signal(str, str)
    cancelled = Signal(str)


class BackupWorker(QRunnable):
    def __init__(self, server, dbname, output_folder):
        super().__init__()
        self.server = server
        self.dbname = dbname
        self.output_folder = output_folder
        self.signals = BackupSignals()
        self.process = None
        self._cancelled = False

    def run(self):
        self.process = QProcess()

        env = os.environ.copy()
        env["PGPASSWORD"] = self.server["password"]

        process_env = self.process.processEnvironment()
        for k, v in env.items():
            process_env.insert(k, v)
        self.process.setProcessEnvironment(process_env)

        output_file = os.path.join(self.output_folder, f"{self.dbname}.backup")

        args = [
            "-h", self.server["host"],
            "-p", str(self.server["port"]),
            "-U", self.server["user"],
            "-F", "c",           # custom format = single .backup file
            "-d", self.dbname,
            "-f", output_file
        ]
        self.process.start("pg_dump", args)
        self.process.waitForFinished(-1)

        if self._cancelled:
            self.signals.cancelled.emit(self.dbname)
            return

        if self.process.exitCode() != 0:
            error = self.process.readAllStandardError().data().decode()
            self.signals.error.emit(self.dbname, error)
        else:
            self.signals.progress.emit(self.dbname, 100)
            self.signals.finished.emit(self.dbname)

    def cancel(self):
        self._cancelled = True
        if self.process:
            self.process.kill()\n\n===== FILE: ./core/workers/restore_worker.py =====\n\n
from PySide6.QtCore import QObject, Signal, QRunnable
from PySide6.QtCore import QProcess
import os


class RestoreSignals(QObject):
    progress = Signal(str, int)
    finished = Signal(str)
    error = Signal(str, str)
    cancelled = Signal(str)


class RestoreWorker(QRunnable):
    def __init__(self, server, backup_path, target_db):
        super().__init__()
        self.server = server
        self.backup_path = backup_path
        self.target_db = target_db  # <-- store target DB
        self.signals = RestoreSignals()
        self.process = None
        self._cancelled = False

    def run(self):
        self.process = QProcess()

        env = os.environ.copy()
        env["PGPASSWORD"] = self.server["password"]

        process_env = self.process.processEnvironment()
        for k, v in env.items():
            process_env.insert(k, v)
        self.process.setProcessEnvironment(process_env)

        # If target_db is None → auto-create original DB from backup
        if self.target_db:
            args = [
                "-h", self.server["host"],
                "-p", str(self.server["port"]),
                "-U", self.server["user"],
                "-d", self.target_db,
                "-c",  # optional: clean tables before restore
                self.backup_path
            ]
        else:
            args = [
                "-h", self.server["host"],
                "-p", str(self.server["port"]),
                "-U", self.server["user"],
                "-C",              # create original DB
                "-d", "postgres",  # connect to default DB for creation
                self.backup_path
            ]
        self.process.start("pg_restore", args)
        self.process.waitForFinished(-1)

        if self._cancelled:
            self.signals.cancelled.emit(self.backup_path)
            return

        if self.process.exitCode() != 0:
            error = self.process.readAllStandardError().data().decode()
            self.signals.error.emit(self.backup_path, error)
        else:
            self.signals.progress.emit(self.backup_path, 100)
            self.signals.finished.emit(self.backup_path)

    def cancel(self):
        self._cancelled = True
        if self.process:
            self.process.kill()\n\n===== FILE: ./core/restore_manager.py =====\n\n
import subprocess
import os


class RestoreManager:

    @staticmethod
    def restore_backup(server, backup_file):
        """
        Restores backup and auto-creates DB using original name
        """
        env = os.environ.copy()
        env["PGPASSWORD"] = server["password"]

        restore_command = [
            "pg_restore",
            "-h", server["host"],
            "-p", str(server["port"]),
            "-U", server["user"],
            "-C",              # create database
            "-d", "postgres",  # connect to default db
            backup_file
        ]

        result = subprocess.run(
            restore_command,
            env=env,
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            raise Exception(result.stderr)

    @staticmethod
    def restore_into_existing_db(server, backup_file, target_db):
        """
        Restores backup into already existing database
        """
        env = os.environ.copy()
        env["PGPASSWORD"] = server["password"]

        restore_command = [
            "pg_restore",
            "-h", server["host"],
            "-p", str(server["port"]),
            "-U", server["user"],
            "-d", target_db,  # connect to the database you want
            "-c",             # optional: clean tables before restoring
            backup_file
        ]

        result = subprocess.run(
            restore_command,
            env=env,
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            raise Exception(result.stderr)\n\n===== FILE: ./core/server_manager.py =====\n\n
import json
import os
import psycopg2

SERVERS_FILE = os.path.join("data", "servers.json")


class ServerManager:

    @staticmethod
    def load_servers():
        if not os.path.exists(SERVERS_FILE):
            return []

        with open(SERVERS_FILE, "r") as f:
            return json.load(f)

    @staticmethod
    def save_servers(servers):
        with open(SERVERS_FILE, "w") as f:
            json.dump(servers, f, indent=4)

    @staticmethod
    def get_databases(server):
        conn = psycopg2.connect(
            host=server["host"],
            port=server["port"],
            user=server["user"],
            password=server["password"],
            dbname="postgres"
        )

        cur = conn.cursor()
        cur.execute("""
            SELECT datname
            FROM pg_database
            WHERE datistemplate = false;
        """)

        dbs = [row[0] for row in cur.fetchall()]

        cur.close()
        conn.close()

        return dbs
\n\n===== FILE: ./core/backup_manager.py =====\n\n
import subprocess
import os


class BackupManager:

    @staticmethod
    def backup_database(server, dbname, output_folder):
        output_file = os.path.join(output_folder, f"{dbname}.backup")

        env = os.environ.copy()
        env["PGPASSWORD"] = server["password"]

        command = [
            "pg_dump",
            "-h", server["host"],
            "-p", str(server["port"]),
            "-U", server["user"],
            "-F", "c",
            "-d", dbname,
            "-f", output_file
        ]

        result = subprocess.run(command, env=env, capture_output=True, text=True)

        if result.returncode != 0:
            raise Exception(result.stderr)
\n\n===== FILE: ./ui/main_window.py =====\n\n
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QListWidget, QFileDialog,
    QMessageBox, QCheckBox, QListWidgetItem,
    QSizePolicy, QInputDialog
)
from PySide6.QtCore import Qt
from core.server_manager import ServerManager
from core.backup_manager import BackupManager
from core.restore_manager import RestoreManager
from concurrent.futures import ThreadPoolExecutor, as_completed
from PySide6.QtCore import QThreadPool
from core.workers.backup_worker import BackupWorker
from core.workers.restore_worker import RestoreWorker


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.threadpool = QThreadPool()
        self.threadpool.setMaxThreadCount(3)
        self.active_workers = []

        self.setWindowTitle("Postgres Bulk Manager")
        self.setMinimumSize(900, 500)

        self.servers = ServerManager.load_servers()
        self.current_server = None

        self.init_ui()

    def init_ui(self):
        main_widget = QWidget()
        main_layout = QHBoxLayout()

        # -----------------------------
        # Left Side
        # -----------------------------
        left_layout = QVBoxLayout()

        self.select_all_cb = QCheckBox("Select All Databases")
        self.select_all_cb.stateChanged.connect(self.toggle_select_all)

        self.db_list = QListWidget()
        self.db_list.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.db_list.setAlternatingRowColors(True)

        left_layout.addWidget(self.select_all_cb)
        left_layout.addWidget(self.db_list)


        # -----------------------------
        # Right Side Buttons
        # -----------------------------
        btn_layout = QVBoxLayout()

        top_btn_layout = QHBoxLayout()

        self.connect_btn = QPushButton("Connect")
        self.refresh_btn = QPushButton("Refresh")

        top_btn_layout.addWidget(self.connect_btn)
        top_btn_layout.addWidget(self.refresh_btn)

        self.backup_btn = QPushButton("Backup Selected")
        self.restore_btn = QPushButton("Restore Backups")
        self.cancel_btn = QPushButton("Cancel All")

        btn_layout.addLayout(top_btn_layout)
        btn_layout.addWidget(self.backup_btn)
        btn_layout.addWidget(self.restore_btn)
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addStretch()

        # -----------------------------
        # Combine Layouts
        # -----------------------------
        main_layout.addLayout(left_layout, stretch=2)
        main_layout.addLayout(btn_layout, stretch=1)

        main_widget.setLayout(main_layout)
        self.setCentralWidget(main_widget)

        # -----------------------------
        # Connect Signals
        # -----------------------------
        self.connect_btn.clicked.connect(self.connect_server)
        self.refresh_btn.clicked.connect(self.refresh_databases)
        self.backup_btn.clicked.connect(self.backup_selected)
        self.restore_btn.clicked.connect(self.restore_backups)
        self.cancel_btn.clicked.connect(self.cancel_all)

    # ---------------------------------
    # Select All
    # ---------------------------------
    def toggle_select_all(self, state):
        for i in range(self.db_list.count()):
            item = self.db_list.item(i)
            item.setCheckState(Qt.Checked if state == Qt.Checked else Qt.Unchecked)


    def cancel_all(self):
        for worker in self.active_workers:
            worker.cancel()
        self.active_workers.clear()


    # ---------------------------------
    # Connect to Server (Select Only)
    # ---------------------------------
    def connect_server(self):
        if not self.servers:
            QMessageBox.warning(self, "Error", "No servers configured.")
            return

        server_names = [s["name"] for s in self.servers]

        server_name, ok = QInputDialog.getItem(
            self, "Select Server", "Server:", server_names, 0, False
        )

        if not ok or not server_name:
            return

        self.current_server = next(
            s for s in self.servers if s["name"] == server_name
        )

        self.load_databases()

    # ---------------------------------
    # Refresh Databases
    # ---------------------------------
    def refresh_databases(self):
        if not self.current_server:
            QMessageBox.warning(self, "Error", "Connect to a server first.")
            return

        self.load_databases()

    # ---------------------------------
    # Load Databases
    # ---------------------------------
    def load_databases(self):
        try:
            dbs = ServerManager.get_databases(self.current_server)
        except Exception as e:
            QMessageBox.critical(self, "Connection Error", str(e))
            return

        self.db_list.clear()

        for db in dbs:
            item = QListWidgetItem(db)
            item.setCheckState(Qt.Unchecked)
            self.db_list.addItem(item)

        self.select_all_cb.setChecked(False)

    # ---------------------------------
    # Backup
    # ---------------------------------
    def backup_selected(self):
        if not self.current_server:
            QMessageBox.warning(self, "Error", "Connect first.")
            return

        folder = QFileDialog.getExistingDirectory(self, "Select Backup Folder")
        if not folder:
            return

        for i in range(self.db_list.count()):
            item = self.db_list.item(i)

            if item.checkState() == Qt.Checked:
                dbname = item.text()

                worker = BackupWorker(self.current_server, dbname, folder)

                worker.signals.progress.connect(
                    lambda db, val, it=item: it.setText(f"{db} ({val}%)")
                )

                worker.signals.finished.connect(
                    lambda db: QMessageBox.information(self, "Done", f"{db} backup finished.")
                )

                worker.signals.error.connect(
                    lambda db, err: QMessageBox.warning(self, "Error", f"{db}: {err}")
                )

                self.threadpool.start(worker)
                self.active_workers.append(worker)


    def restore_backups(self):
        if not self.current_server:
            QMessageBox.warning(self, "Error", "Connect first.")
            return

        files, _ = QFileDialog.getOpenFileNames(
            self, "Select Backup Folders", ""
        )

        if not files:
            return

        for path in files:
            # Determine which DB the user wants to restore into
            selected_dbs = [
                self.db_list.item(i).text()
                for i in range(self.db_list.count())
                if self.db_list.item(i).checkState() == Qt.Checked
            ]

            # 1 file + 1 selected DB → restore into that database
            if len(selected_dbs) == 1 and len(files) == 1:
                worker = RestoreWorker(self.current_server, files[0], selected_dbs[0])
                self.threadpool.start(worker)
                self.active_workers.append(worker)

            # Otherwise → auto-create DB from backup (original name)
            else:
                for file in files:
                    worker = RestoreWorker(self.current_server, file, None)  # target_db=None triggers auto-create
                    self.threadpool.start(worker)
                    self.active_workers.append(worker)

            worker.signals.finished.connect(
                lambda p: QMessageBox.information(self, "Restore Done", f"{p} restored.")
            )

            worker.signals.error.connect(
                lambda p, err: QMessageBox.warning(self, "Error", f"{p}: {err}")
            )

            self.threadpool.start(worker)
            self.active_workers.append(worker)\n\n===== FILE: ./main.py =====\n\n
import sys
from PySide6.QtWidgets import QApplication
from ui.main_window import MainWindow


if __name__ == "__main__":
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    sys.exit(app.exec())